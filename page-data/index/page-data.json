{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"4402668f-189c-5274-82f1-88d33245ace7","excerpt":"기존 MVC의 문제점 mvc 프로젝트 규모가 커질수록 빠르게 복잡해진다. feature 추가될 때마다 모델과 뷰를 연결하는 복잡성이 증가한다. 데이터 간의 의존성과 연쇄적인 갱신은 뒤얽힌 데이터 흐름을 만들고 예측할 수 없는 결과로 이끌게 된다. 새로온 개발자가 합류하면, 너무 복잡해서 코드만 보고 해석이 힘들다. (유지비용 증가) 복잡성이 증가할 수록 예측 불가능해지고 안정성이 떨어진다. (어디서 버그가 터져나올지 테스트도 어렵다.) 이 프로젝트는 파생되는 데이터를 올바르게 다루기 위해 시작되었다. 예를 들면 현재 뷰에서 읽지 않은 메시지가 강조되어 있으면서도 읽지 않은 메시지 수를 상단 바에 표시하고 싶었다. 이런 부분은 MVC에서 다루기 어려운데 메시지를 읽기 위한 단일 스레드에서 메시지 스레드 모델을 갱신해야하고 동시에 읽지 않은 메시지 수 모델을 갱신 해야하기 때문이다. Flux Flux는 Facebook에서 소개한 아키텍쳐입니다. 전통적인 MVC 패턴을 버리고, 개발이 …","frontmatter":{"categories":"design","title":"Flux 패턴","date":"April 02, 2022"},"fields":{"slug":"/design-flux-pattern/"}}},{"node":{"id":"a30f0651-2dd8-5eb4-8a80-6714b2809564","excerpt":"반응형 웹이란, 하나의 웹사이트에서 PC, 스마트폰, 태블릿 PC 등 접속하는 디스플레이의 종류에 따라 화면의 크기가 자동으로 변하는 웹 페이지를 의미합니다. 오늘날에는 IT 기기의 종류가 더욱 다양해짐에 따라 디스플레이의 크기에 맞게 유동적으로 반응하는 반응형 웹을 구현하는 것이 더욱 중요하다. 일반적인 Breakpoint responsive desktop 스타일링: 1920 ~ 1024px ipad 스타일링: 1024 ~ 768px phone 스타일링: 768 ~ 0px 보통 2개(1024 / 768)를 이용한다 관리를 편하게 하려면 1개(768)를 이용한다 CSS 반응형 Media Query  : media 쿼리를 시작  : 어떤 디바이스에서 적용하는지 알려줍니다. 예를 들면 프린트를 하고싶을 때 적용하려면 only print라고 작성하면 됩니다. screen이라고 할 경우 어떤 디바이스에 상관없이, 화면에 보이는 스크린이기만 하면 전부 적용됩니다.  : 이건 media fe…","frontmatter":{"categories":"css","title":"Responsive Web","date":"March 30, 2022"},"fields":{"slug":"/css-responsive-web/"}}},{"node":{"id":"957d1656-392a-55cd-9355-828ac6099779","excerpt":"일반적으로 this는 클래스(class)에서만 사용하며, class로 생성한 인스턴스 객체를 의미하나, JavaScript에서는 그렇지 않고 this가 가르키는 대상이 항상 달라집니다. 함수와 메서드 함수와 메서드는 모두 function 키워드로 함수를 정의한 것을 의미 메서드는 객체의 프로퍼티로 함수가 정의되어야 한다.\n중요한건 객체가 함수를 호출해야 메서드이다!!! this this란?\nthis가 바라보고 있는 객체인데, 상황에 따라 대상이 달라진다. this는 실행컨텍스트가 생성될 때 결정된다.\n실행컨텍스트는 함수를 호출할 때 생성되므로, this는 함수를 호출할 때 결정된다. this의 동작 방식 전역 공간에서 this client(브라우저)에서는 window Node.js에서는 global 메서드로 호출될 때 this (암시적 binding) 객체의 프로퍼티에 할당된 함수를 호출하면, this는 해당 객체를 바라본다 물론 객체가 메서드로 호출해야 함 arrow functi…","frontmatter":{"categories":"javascript","title":"This","date":"March 26, 2022"},"fields":{"slug":"/js-this/"}}},{"node":{"id":"865d6b72-cf33-5cfe-b3f8-bd60281c4c84","excerpt":"Closure 함수를 선언할 때 만들어진 scope가 사라진 후에도 호출할 수 있는 함수 함수가 선언됐을 때가 중요. scope가 끝난 외부 함수의 변수를 참조할 수 있다. 일급 객체 함수의 개념을 이용하여 스코프에 묶인 변수를 바인딩 하기 위한 일종의 기술\n함수를 일급 객체로 취급하는 여러 함수형 프로그래밍 언어에서 사용되는 보편적인 특성 일급 객체 함수 란?\n다른 객체 및 함수 들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체 및 함수를 가리킨다. 일극 객체 함수의 조건 변수에 할당 할 수 있다 다른 함수를 인자로 전달 받을 수 있다 다른 함수의 결과로서 return 될 수 있다. Closure 예제 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우,\nA의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상  에서 함수 B자체를 반환  실행했으므로 A의 실행컨텍스트는 종료됨  변수는 이제 를 바라보고 있음  outer를 호출하면, 즉…","frontmatter":{"categories":"javascript","title":"Closure","date":"March 23, 2022"},"fields":{"slug":"/js-closure/"}}},{"node":{"id":"d8246656-ea75-50d3-ae7a-e84b11447f77","excerpt":"Scope란? Scope : 변수가 유효한범위 Scope 종류 Global Scope var로 선언한 변수는 전역 객체에 속하게 된다.(프로퍼티가 된다) client(브라우저)의 전역 객체는 , Node.js에서는  Local Scope JavaScipt는 다른 언어와 달리 scope의 범위가 함수 블록 내이다.\n즉, ( ), { } 블록과 상관이 없고, 함수에 의해서만 scope가 생성된다. ⚠️ JavaScipt에서 let, const로 변수를 선언할 때의 scope은 블록({}) 단위이다. Scope Chain 변수가 해당 scope에서 유효하지 않을 때, 안에서부터 바깥으로 차례로 검색해 나가는 것 Scope 예제 Scope란? Scope 종류 Global Scope Local Scope Scope Chain Scope 예제","frontmatter":{"categories":"javascript","title":"Scope","date":"March 19, 2022"},"fields":{"slug":"/js-scope/"}}},{"node":{"id":"071feb74-cce4-5346-9fda-30a92995c1dc","excerpt":"함수 선언문과 함수 표현식 함수 선언문(function declaration) function 정의만 존재하고 별도의 할당 명령이 없다. 함수 표현식(function expression) function 키워드로 정의한 함수를 변수에 할당하는 것을 말한다. Hoisting 변수의 선언을 끌어올리는 것을 말한다. 선언부는 끌어올리고, 할당은 코드가 실행되는 시점에 진행된다. 변수의 Hoisting 전 변수 Hoisting 후 함수 Hoisting 함수 선언식 함수 표현식 let, const의 Hoisting Hoisting이 되지 않는것 처럼 보인다. Temporal Dead Zone(TDZ) let, const 역시 마찬가지로 LexicalEnvironment에 변수 정보를 미리 수집한다\n(hoisting의 개념으로 알고 있는 동작) let, const는 실행되기 전까지 액세스 할 수 없고, 이 단계(공간)를 TDZ라고 함 Hoisting 예제 이런 느낌으로 environmentR…","frontmatter":{"categories":"javascript","title":"Hoisting","date":"March 16, 2022"},"fields":{"slug":"/js-hoisting/"}}},{"node":{"id":"a96eccdd-d53b-5582-a0af-90061086aacb","excerpt":"👉🏻 JavaScript의 런타임 모델은 코드의 실행, 이벤트의 수집과 처리, 큐에 대기 중인 하위 작업을 처리하는 이벤트 루프에 기반하고 있습니다. 이벤트 루프 event-loop 힙: 단순히 메모리 영역을 지칭하는 용어. 메모리 할당이 이루어지는 곳으로 변수 등의 정보 저장. (콜스택의 최상단에 있는 실행 컨텍스트가 실행되면서 참조되는 객체들이 저장되어 있는 메모리 공간) 콜스택: 실행하는 코드를 순서대로 실행하는 곳 (실행 컨텍스트가 추가되거나 제거되며 코드의 실행순서를 관리) 콜백큐: 처리할 메시지의 대기열 (비동기 함수의 콜백함수 또는 이벤트 핸들러가 일시적으로 대기) 예제로 콜스택 내부 확인하기 call-stack 이벤트루프 작동 확인하기 greet 호출 => respond 호출 gif1 Web API인 setTimout 호출, setTimeout의 cb 전달 gif2 cb는 1초뒤에 콜백큐로 전달 gif3 콜스택 비어있을 때, 콜백큐에 있던 대기 작업 하나씩 전달 gif…","frontmatter":{"categories":"javascript","title":"EventLoop","date":"March 12, 2022"},"fields":{"slug":"/js-event-loop/"}}},{"node":{"id":"f1d433e3-870d-5e29-aa12-936b354460ec","excerpt":"Promise란? Promise는 비동기 동작을 처리하기 위해 ES6에 도입되었다. Promise는 클래스이고, Promise 클래스를 인스턴스화 해서 promise 객체를 만든다. 반환된 promise로 원하는 비동기 동작을 처리한다. Promise는 와 ,  함수를 이해해야 된다. Promise 기본 형태 구현하기 promise 3가지 상태(State) Pending(대기) 비동기 처리 로직이 아직 완료되지 않은 상태 Fulfilled(이행) 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태 Rejected(실패) 비동기 처리가 실패하거나 오류가 발생한 상태 resolve, reject 이해하기 resolve 비동기 로직이 성공했을 때 실행할 함수 reject 비동기 로직이 실패했을 때 실행할 함수 resolve 호출시 전달되는 인자 → then 콜백함수의 매개변수로 받는다. 에러 처리 - reject 두 번째 인자로 에러처리 로직을 작성하시거나, 아래와 같이 catc…","frontmatter":{"categories":"javascript","title":"Promise","date":"March 09, 2022"},"fields":{"slug":"/js-promise/"}}},{"node":{"id":"f5b0fe75-b829-51eb-bd27-2fe6a4723b85","excerpt":"콜백 함수란? 함수의 매개변수가 함수일 때, 매개변수로 받은 함수를 콜백함수르고 부른다. 고차 함수(Higher Order Function)란? 매개변수를 함수로 받은 함수. 즉, 외부에서 콜백함수를 전달받은 함수 고차 컴포넌트 (Higher Order Component(HOC))란? 컴포넌트를 매개변수로받아서, 컴포넌트를 반환하는 컴포넌트 일급함수란? 함수를 다른 변수와 동일하게 다루는 언어는 일급 함수를 가졌다고 표현합니다. 예를 들어, 일급 함수를 가진 언어에서는 함수를 다른 함수에 인수로 제공하거나, 함수가 함수를 반환할 수 있으며, 변수에도 할당할 수 있습니다. 일급함수의 특징 함수를 변수에 할당 가능 함수를 또 다른 함수 인자로 전달 가능 함수의 반환값으로 함수 전달 가능 함수형 프로그래밍 특징 중의 하나가 바로 일급함수 입니다. 콜백함수 사용하기 콜백함수라고 해서 꼭 비동기 동작에 쓰이는 것이 아닙니다. 콜백 함수란? 고차 함수(Higher Order Function)…","frontmatter":{"categories":"javascript","title":"콜백 함수","date":"March 05, 2022"},"fields":{"slug":"/js-call-back-function/"}}},{"node":{"id":"33a460aa-d5c7-50e9-bb1a-8e7274038386","excerpt":"동기(Synchronouse) 동기란? 현재 실행 중인 코드가 끝나야 다음 코드를 실행하는 방식 동기의 장/단점 장점: 코드를 순서대로 하나씩 실행하기 때문에, 실행 순서가 보장된다. 단점: 현재 실행중인 task가 종료될 때까지 다음 task가 실행이 안 된다는 문제 (task blocking) 전형적인 동기 task blocking 예제 비동기(Asynchronouse) 비동기란? 현재 실행 중인 코드가 완료되지 않아도, 다음 코드로 넘어감. 즉, 비동기 task(코드)는 실행하라고 브라우저에 맡겨놓고, 다음 task(코드)로 넘어감 비동기의 장/단점 장점: 현재 실행중인 task가 완료되지 않아도, 다음 task를 실행하기 때문에 블로킹이 발생 X 단점: task의 실행 순서가 보장되지 않는다. 비동기 처리가 필요한 이유 자바스크립트 엔진은 한 번에 하나의 task만 실행할 수 있는 Single Thread. Single Thread는처리에 시간이 걸리는 task를 실행하는 …","frontmatter":{"categories":"javascript","title":"동기와 비동기","date":"March 02, 2022"},"fields":{"slug":"/js-synch-asynch/"}}},{"node":{"id":"681fc8e4-61bc-52c7-8e74-2750c9a109af","excerpt":"styled-components 설치 styled-components는 각기 다른 컴포넌트들에게 스타일링의 영향을 주지 않기 위해 Local로 동작 styled-components 기본 예제 styled-components props 예제 Circle 컴포넌트에  props 값을 설정해줬으면 해당 값을 배경색으로 설정하고, 그렇지 않으면 검정색. styled-components 상속 styled-components As 속성 만약 Button 컴포넌트의 스타일은 그대로 쓰고싶지만, 태그의 종류를 button이 아닌 a 태그로 바꾸고 싶을땐 ‘as’ 속성을 사용 styled-components Attributes 삽입하기 styled-components css 예제 여러 줄의 CSS 코드를 조건부로 보여주고 싶다면 를 사용한다. 를 불러와서 사용을 해야 그 스타일 내부에서도 다른 를 조회 할 수 있다. styled-components 애니메이션 styled-components The…","frontmatter":{"categories":"css","title":"Styled Components 정리","date":"February 26, 2022"},"fields":{"slug":"/css-styled-components-summary/"}}},{"node":{"id":"64569e13-22e9-5373-9b70-c19c10287ef3","excerpt":"Sass(Syntactically Awesome Style Sheets)  는  로서, 복잡한 작업을 쉽게 할 수 있게 해주고, 코드의 재 활용성을 높여줄 뿐 만 아니라, 코드의 가독성을 높여주어 유지보수를 쉽게해줍니다.  란?\n 를 확장하는 스크립팅 언어로서, 컴파일러를 통하여 브라우저에서 사용 할 수 있는 일반  문법 형태로 변환됩니다. Sass / Scss React에서 사용법 Comment (주석) 의 주석이 CSS 와 다른점은 ****이 추가되었다는 점 입니다. 은  표기하며,   컴파일 되었을 때 나타나지 않습니다 은  와 동일하며  로 컴파일 되었을 때 나타납니다. Variable (변수)  는 에  개념을 도입한다. 변수가 가능한 형태 : , , , , , ,  변수를 사용 할 때에는  문자를 사용합니다. 변수를 만들어도, 사용하지 않으면 컴파일된  파일에는 아무것도 나타나지 않습니다. Variable Scope 변수를  에서 선언 ⇒  접근가능 Global Vari…","frontmatter":{"categories":"css","title":"Sass/Scss 정리","date":"February 19, 2022"},"fields":{"slug":"/css-sass-scss-summary/"}}},{"node":{"id":"6aeb5fe5-bc4a-5efc-b154-7e1af02d6cc3","excerpt":"Git 기본 구조 코드는 세 단계에 걸쳐 저장 :  ⇒  ⇒   으로 파일을  상태에 넣는다.  으로  상태에 있는 모든 변경사항을 한다. 여기까지가 에서 작업이다.  ⇒ local repository의 내용을 remote repository로 업로드한다 Git 주요 명령어  저장소 생성  원격 저장소로부터 복제, zip 파일로 받으면 .git 폴더가 없다는 것이 차이점  변경 사항 체크  working directory의 변경된 작업 파일을 staging area로 추가  변경된 모든 파일 스테이징  staging area의 내용을 local repository에 확정  local repository의 내용을 remote repository로 업로드  원격저장소 추가  Remote Repo branch에서 데이터를 가져와 자동으로 local branch와 merge Commit 관련 Git 명령어 커밋 합치기  커밋 메세지 수정  간단한 commit방법   커밋 이력 확인    …","frontmatter":{"categories":"git","title":"Git 명령어 정리","date":"February 12, 2022"},"fields":{"slug":"/git-command-gather/"}}},{"node":{"id":"6d425db0-c753-5bb8-8120-4672154e8bea","excerpt":"이란 ? 팀장의 저장소를 해서 팀원마다 각자 저장소를 가지고 프로젝트를 진행하는 방식이다. 팀원의 작업 내용은 를 통해 팀장의 확인 후 반영된다. 팀장 저장소의 권한은 만 가지고 있으면서 다른 사람의 을 프로젝트에 적용이 가능하다. 팀장이 코드를 확인하고 하기 때문에 안전하게 협업이 가능하다. 오픈소스프로젝트에서 많이 사용하는 방식이다. 하기 1.  하기 fork  타인 소유의(또는 공동 소유의) 프로젝트 소스와 commit 내역, branch 등 원본 Remote Repository의 구조를 그대로 복사하여 내 소유의 새로운 Remote Repository로 생성하는 기능이다.\nFork한 저장소는 내 소유이므로 내 마음대로 Source를 수정할 수 있다. 이때 Fork 저장소의 내용을 아무리 수정해도 원본 저장소엔 영향을 주지 않는다.따라서 Fork 저장소를 이용하면 Git 기능을 마음껏 활용하여 소스를 수정해볼 수 있으면서도 원본 Source에 대한 무분별한 수정을 막을 수 있…","frontmatter":{"categories":"git","title":"Git Forking Workflow 협업하기","date":"February 05, 2022"},"fields":{"slug":"/git-forking-workflow-collaborate/"}}},{"node":{"id":"2beeea05-826d-5f0c-960e-b73bcba1a62e","excerpt":"Git 협업 준비하기  등록 및 초대하기 협업 할 git repository에서 Settings 클릭하기 왼쪽 메뉴에서 Collaborators 클릭하기 github password 입력하기 Manage access에서 Add people 클릭하기 협업 할 동료 초대하기 collaborator 등록하면 모든 협업 동료들은  &  권한을 획득한다.  초대 확인하기 github에 등록한 메일 주소로 초대 메일 확인하여  클릭하기 Git 협업하기 1.  하기 2.  생성 &  이동 3. 작업 후 git , ,  하기 4. 에 병합 or  에 병합하기 는 최신 코드  &  용도로만 사용하는 것이 관리면에서 편하다.  이동할 때, 작업을 마무리하고 을 한 후 이동해야 한다. \n즉, 에 작업 내용이 있으면 이동이 안된다. 에 병합하기 github repository에 가서 pull requests 작성하고 팀원들에게 피드백 받기 팀원들이 피드백 후 merge 하기 5. 최신 버전 가져오기 +…","frontmatter":{"categories":"git","title":"Git 협업하기","date":"January 29, 2022"},"fields":{"slug":"/git-collaborate/"}}},{"node":{"id":"258b7fb8-e5f0-5849-9bb2-a860714db500","excerpt":"BEM의 기본 구조 BEM은 Block, Element, Modifier를 뜻한다. BEM은 어떤 목적인가에 따라 이름을 만든다. Blcok, Element, Modifier은  _ _ 와 - - 로 구분한다. 이름을 연결할때에는 -를 사용한다. header는 Block, naviagtion은 Element, navi-text는 Modifier가 됩니다. Block 재사용 가능한 기능적으로 독립적인 페이지 컴포넌트을 Block이라고 부른다. 또, Block은 Block으로 감쌀 수 있습니다. Element Element는 Block을 구성하는 단위이다. Block은 독립적인 형태인 반면, Element는 의존적인 형태이다. 자신이 속한 블럭 내에서만 의미를 가지기 때문에 블럭 안에서 떼어다 다른 데 쓸 수 없다. .search-form은 Block이, .search-form__input과 .search-form__button은 Element이다. Modifier Modifier는 …","frontmatter":{"categories":"css","title":"Css BEM 방식","date":"January 22, 2022"},"fields":{"slug":"/css-bem-method/"}}},{"node":{"id":"e0608aa1-9558-5204-ba0a-4c2f1706d788","excerpt":"1. 자바스크립트 완벽 가이드 자바스크립트_완벽_가이드 2. 프론트엔드 개발자를 위한 자바스크립트 프로그래밍 프론트엔드_개발자를_위한_자바스크립트_프로그래밍 3. 모던 자바스크립트 Deep Dive 모던_자바스크립트_Deep_Dive 1. 자바스크립트 완벽 가이드 2. 프론트엔드 개발자를 위한 자바스크립트 프로그래밍 3. 모던 자바스크립트 Deep Dive","frontmatter":{"categories":"developer","title":"Frontend Developer 필독서","date":"January 15, 2022"},"fields":{"slug":"/dev-frontend-developer-must-read/"}}},{"node":{"id":"f669f320-02a0-57f3-959b-792ad750147d","excerpt":"👋 나만의 blog 만들기 gatsby 테마로 github blog 만들기 netlify로 zoomkoding-gatsby-blog 만들기 🏃‍♀️ 로컬 환경에 블로그를 실행하기 위 명령어가 문제 없이 실행됐다면 http://localhost:8000에서 블로그를 확인하실 수 있습니다. ⚙️ 블로그 정보 바꾸기 에 있는 여러값들을 변경해줍니다. 1. 블로그 기본 정보 설정하기 2. 댓글 설정 블로그 글들에 댓글을 달 수 있길 원하신다면 utterances를 통해서 이를 설정하실 수 있습니다. 🦄 utterances 사용방법은 링크를 참고해주세요! 3. 글쓴이 정보 author에 입력하신 정보는 홈페이지와 about 페이지 상단에 있는 글쓴이를 소개하는 섹션인 bio에서 사용됩니다.\ndescription에 자신을 설명하는 문구들을 넣으면 애니메이션으로 보여지게 됩니다.\nbio 이미지는 에 원하시는 파일을 추가하고 파일의 이름을 thumbnail에 넣어주시면 됩니다. (gif 지원) 🤖 위에…","frontmatter":{"categories":"blog","title":"블로그 설정 & 글쓰기","date":"January 08, 2022"},"fields":{"slug":"/blog-setting-and-writing/"}}},{"node":{"id":"f4662b5f-5f22-5863-a039-dcb24b0ca70d","excerpt":"1. Repository 생성하기 GitHub에 로그인 후 우측 상단에 있는 New Repository 버튼을 클릭하면 repository 생성하기\ngithub-blog\n Import a repository 버튼을 클릭합니다\ngithub-blog-1 생성할 respository 정보 입력하기\ngithub-blog-2 Your old repository’s clone URL에 사용할 gatsby 테마가 있는 repository 주소를 넣기 제 블로그 테마는 https://github.com/zoomKoding/zoomkoding.com입니다. Repository Name을 [GitHubID].github.io로 설정하기 Begin Import 버튼을 클릭하기 최종 repository 생성 결과\ngithub-blog-3 2. Repository 가져오기 및 블로그 배포 준비 Repository에서 초록색 Code 버튼을 클릭하면 링크가 나오게 되는데, 이 링크를 복사하기\ngithub-…","frontmatter":{"categories":"blog","title":"Gatsby 테마로 GitHub Blog 만들기","date":"January 01, 2022"},"fields":{"slug":"/blog-gatsby-theme-github-blog/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"정인권","bio":{"role":"개발자","description":["새로운 것을 두려워하지 않는","끊임없이 고민하는","함께 소통하며 성장하는","평생 학습하고 도전하는"],"thumbnail":"sample.png"},"social":{"github":"https://github.com/developjik","linkedIn":"https://www.linkedin.com/in/%EC%9D%B8%EA%B6%8C-%EC%A0%95-149303234/","email":"developjik@gmail.com"}}}}},"pageContext":{}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437","3350743975"]}